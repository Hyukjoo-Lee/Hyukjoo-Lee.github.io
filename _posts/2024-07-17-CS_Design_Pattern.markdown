---
title: "{ CS } Design Pattern"
date: 2024-07-17 22:00:00 +07:00
tags: [Design Pattern, Gof, Creational, Structural, Behavioral]
---

## 디자인 패턴

- 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현방법으로 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제를 의미한다

## 디자인 패턴의 장점

- 범용적인 코딩 스타일로 구조 파악 용이
- 객체지향 설계 및 구현의 생산성을 높이는 데 적합함
- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약

## 디자인 패턴 유형

- 생성 패턴, 구조 패턴, 행위 패턴 (Gof)

## 생성 패턴

- 객체의 생성 방식을 다루며 주요 목적은 객체 생성 프로세스를 추상화하여 응용 프로그램의 유연성과 확장성을 향상 시키는 것
- 새로운 객체를 생성하고 조합하는 방법에 대한 일반적인 해결책을 제시

### 생성 패턴명

- 추상 팩토리 (abstact factory): 구체적인 클래스에 의존하지 않고 인터페이스를 통해 서로 연관/의존하는 객체들의 그룹으로 생성하여 추상적으로 표현함
- 빌더 (builder): 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성
- 팩토리 메소드 (factory method): 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴으로 상위 클래스에서 인터페이스만 정의하고 실제 생성은 서브클래스가 담당. 가상 생성자 (virtual constructor) 패턴이라고도 함
- 프로토타입 (prototype): 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴
- 싱글톤 (singleton): 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만 여러 프로세스가 동시에 참조할 수 없음

## 구조 패턴

- 소프트웨어의 구조를 개선하고 유지보수를 용이하게 만드는 패턴
- 프로그램의 다양한 구성 요소들 간의 관계를 조직화하고 코드의 재사용성을 높이며 유연성을 확보하는 데 중요한 역할을 함

### 구조 패턴명

- 어댑터 (adapter): 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브리지 (bridge): 구현부에서 추상층을 분리하여 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 컴포지트 (composite): 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴, 객체 관계를 트리 구조로 구성함
- 데코레이더 (decorator): 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴으로 임의의 객체에 부가적인 기능을 추가하기 위해 다른 객체들을 덧붙이는 방식으로 구현함
- 퍼싸드 (facade): 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수 있도록 하는 패턴
- 플라이웨이트 (flyweight): 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 한 공유해서 사용함으로써 메모리를 절약하는 패턴
- 프록시 (proxy): 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴 / 대리 객체 / 정보 은닉화 가능

## 행위 패턴

- 객체 간의 상호작용을 중심으로 설계되며 객체들간의 역할,책임,행동에 대한 패턴을 제공함
- 애플리케이션의 행위를 구조화하고 관리하는 데 도움이 됨

### 행위 패턴명 (키워드만)

- 책임 연쇄 (chain of responsibility): 체인 형태 / 둘 이상의 객체
- 커멘드 (command): 요청을 객체의 형태로 캡슐화 / 요청자 / 처리자
- 인터프리터 (interpreter): 언어 / 해석 / 문법 정의
- 반복자 (iterator): 요소들을 순차적 접근 / 동일한 인터페이스
- 중재자 (mediator): 상호작용
- 메멘토 (memento): 객체의 내부 상태를 객체화 / 저장하고 복윈 / ctrl + z
- 옵서버 (observer): 상태 변화 관찰 / 알림
- 상태 (state): 객체 내부 상태 -> 객체 동작 다르게 처리
- 전략 (strategy): 알고리즘 / 상호교환
- 템플릿 메소드 (template method): 알고리즘 / 하위 클래스에서 세부 처리 구체화
- 방문자 (visitor): 처리 기능을 분리 / 별도의 클래스
